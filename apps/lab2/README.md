# Lab2

## Титульный лист

- Студент: `Соколов Анатолий Владимирович`
- Группа: `P3312`
- ИСУ: `368823`

---

## Требования к разработанному ПО

1. Реализовать структуру данных "Множество" с открытой адресацией.
2. Обеспечить основные операции:
   - создание,
   - добавление,
   - удаление,
   - фильтрация,
   - отображение,
   - свертка (левая и правая),
   - объединение.
3. Реализовать поведение (behaviour) для множества.
4. Обеспечить тестирование, включая property-based тесты.

## Ключевые элементы реализации

1. Структура `OpenAddressSet`:

   - Использует map для хранения элементов
   - Поддерживает ограничение по емкости
   - Реализует линейное пробирование

2. Основные функции:

   - `new/1`: создание нового множества
   - `add/2`: добавление элемента
   - `remove/2`: удаление элемента
   - `filter/2`: фильтрация элементов
   - `map/2`: отображение элементов
   - `fold_left/3` и `fold_right/3`: свертка
   - `union/2`: объединение множеств

3. Поведение `SetBehaviour`:

   - Определяет интерфейс для реализации множества

4. Тестирование:
   - Модульные тесты для всех операций
   - Property-based тесты для проверки свойств моноида

## Примеры использования

Вот несколько примеров использования реализованного множества:

```elixir
# Создание нового множества
set = Lab2.OpenAddressSet.new(10)

# Добавление элементов
{:ok, set} = Lab2.OpenAddressSet.add(set, 1)
{:ok, set} = Lab2.OpenAddressSet.add(set, 2)
{:ok, set} = Lab2.OpenAddressSet.add(set, 3)

# Удаление элемента
set = Lab2.OpenAddressSet.remove(set, 2)

# Фильтрация элементов
even_set = Lab2.OpenAddressSet.filter(set, fn x -> rem(x, 2) == 0 end)

# Отображение элементов
doubled_set = Lab2.OpenAddressSet.map(set, fn x -> x * 2 end)

# Свертка (сумма всех элементов)
sum = Lab2.OpenAddressSet.fold_left(set, 0, fn x, acc -> x + acc end)

# Объединение множеств
set1 = Lab2.OpenAddressSet.new(5)
{:ok, set1} = Lab2.OpenAddressSet.add(set1, 1)
{:ok, set1} = Lab2.OpenAddressSet.add(set1, 2)

set2 = Lab2.OpenAddressSet.new(5)
{:ok, set2} = Lab2.OpenAddressSet.add(set2, 2)
{:ok, set2} = Lab2.OpenAddressSet.add(set2, 3)

union_set = Lab2.OpenAddressSet.union(set1, set2)

# Проверка на пустоту
is_empty = Lab2.OpenAddressSet.empty?(set)

# Получение размера множества
size = Lab2.OpenAddressSet.size(set)

# Преобразование в список
list = Lab2.OpenAddressSet.to_list(set)
```

## Тесты и метрики

### Тесты

Реализованы следующие группы тестов:

- Добавление элементов
- Удаление элементов
- Фильтрация
- Отображение
- Свертка (левая и правая)
- Объединение множеств
- Свойства моноида (ассоциативность, идентичность, коммутативность)

### Отчет инструмента тестирования

Для запуска тестов использовалась команда `mix test`. Все тесты прошли успешно.

### Метрики

```shell
> mix test
==> stream_data
Compiling 3 files (.ex)
Generated stream_data app
==> lab2
Generated lab2 app
Running ExUnit with seed: 680767, max_cases: 22

..............
Finished in 0.1 seconds (0.00s async, 0.1s sync)
3 properties, 11 tests, 0 failures
```

- Производительность: O(1) для основных операций в среднем случае
- Использование памяти: O(n), где n - количество элементов в множестве

## Выводы

В ходе выполнения лабораторной работы были применены следующие приемы программирования:

1. Функциональное программирование: использование функций высшего порядка (map, filter, fold).
2. Иммутабельность данных: все операции создают новые структуры, не изменяя исходные.
3. Паттерн проектирования "Поведение" (Behaviour): определение интерфейса для множества.
4. Property-based тестирование: использование StreamData для генерации тестовых данных и проверки свойств.
5. Модульное тестирование: подробные тесты для каждой функции.
6. Документирование кода: использование @moduledoc и @doc для описания модулей и функций.

Реализация множества с открытой адресацией позволила эффективно работать с данными, о
беспечивая быстрый доступ и модификацию элементов. Использование Elixir
и его функциональных возможностей сделало код чистым и легко тестируемым.

Опыт разработки показал важность правильного выбора структуры данных
и алгоритмов для эффективной работы с множествами.
Применение property-based тестирования позволило выявить и исправить потенциальные проблемы,
связанные с граничными случаями и свойствами моноида.
